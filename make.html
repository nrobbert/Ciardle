<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Image Cropper</title>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
<style>
    /* CSS Variables for consistent theming */
    :root {
        --primary-color: #2563eb;
        --primary-hover: #1d4ed8;
        --secondary-color: #e5e7eb;
        --secondary-hover: #d1d5db;
        --text-primary: #374151;
        --text-secondary: #6b7280;
        --border-color: #d1d5db;
        --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
        --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
        --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
        --border-radius: 0.5rem;
        --border-radius-lg: 0.75rem;
        --border-radius-xl: 1rem;
    }

    body {
        margin: 0;
        font-family: 'Inter', sans-serif;
        background-color: #f3f4f6; /* Light gray background */
        display: flex;
        justify-content: center;
        align-items: flex-start; /* Align to top */
        min-height: 100vh;
        padding: clamp(10px, 3vw, 20px); /* Fluid padding */
    }
    
    #app-container {
        max-width: clamp(300px, 95vw, 1200px); /* Fluid max width */
        width: 100%;
        background-color: #ffffff;
        border-radius: var(--border-radius-xl);
        box-shadow: var(--shadow-lg);
        padding: clamp(1rem, 4vw, 1.5rem); /* Fluid padding */
    }
    
    canvas {
        display: block;
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius-lg);
        background-color: #f9fafb;
        max-width: 100%; /* Ensure canvas scales */
        height: auto; /* Maintain aspect ratio */
        cursor: crosshair;
    }
    
    .input-group {
        display: flex;
        flex-direction: column; /* Stack vertically on mobile */
        gap: clamp(0.5rem, 2vw, 1rem); /* Fluid gap */
    }
    
    /* Responsive input groups */
    @media (min-width: 640px) {
        .input-group {
            flex-direction: row;
            align-items: center;
        }
    }
    
    .button-primary {
        background-color: var(--primary-color);
        color: #ffffff;
        padding: clamp(8px, 2vw, 12px) clamp(16px, 4vw, 24px); /* Fluid padding */
        border-radius: var(--border-radius-lg);
        box-shadow: var(--shadow-sm);
        border: 1px solid var(--primary-color);
        font-size: clamp(0.875rem, 2.5vw, 1rem); /* Fluid typography */
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease-in-out;
        min-height: 44px; /* Minimum touch target */
        min-width: 44px; /* Minimum touch target */
    }
    
    .button-primary:hover {
        background-color: var(--primary-hover);
        box-shadow: var(--shadow-md);
        transform: translateY(-1px);
    }
    
    .button-secondary {
        background-color: var(--secondary-color);
        color: var(--text-primary);
        padding: clamp(8px, 2vw, 12px) clamp(16px, 4vw, 24px); /* Fluid padding */
        border-radius: var(--border-radius-lg);
        box-shadow: var(--shadow-sm);
        border: 1px solid var(--border-color);
        font-size: clamp(0.875rem, 2.5vw, 1rem); /* Fluid typography */
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease-in-out;
        min-height: 44px; /* Minimum touch target */
        min-width: 44px; /* Minimum touch target */
    }
    
    .button-secondary:hover {
        background-color: var(--secondary-hover);
        box-shadow: var(--shadow-md);
        transform: translateY(-1px);
    }
    
    .img-thumbnail {
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius-lg);
        object-fit: contain;
        width: 100%;
        height: auto;
        aspect-ratio: 4/3; /* Consistent aspect ratio */
        min-height: 80px; /* Minimum size for mobile */
    }
    
    /* Responsive grid for thumbnails */
    #croppedImages {
        display: grid;
        grid-template-columns: 1fr; /* Single column on mobile */
        gap: clamp(0.75rem, 3vw, 1rem);
    }
    
    @media (min-width: 480px) {
        #croppedImages {
            grid-template-columns: repeat(2, 1fr); /* Two columns on small tablets */
        }
    }
    
    @media (min-width: 640px) {
        #croppedImages {
            grid-template-columns: repeat(5, 1fr); /* Five columns on desktop */
        }
    }
    
    /* Input field improvements */
    input[type="text"] {
        width: 100%;
        padding: clamp(8px, 2vw, 12px) clamp(12px, 3vw, 16px); /* Fluid padding */
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        font-size: clamp(0.875rem, 2.5vw, 1rem); /* Fluid typography */
        min-height: 44px; /* Touch target minimum */
        transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    }
    
    input[type="text"]:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }
    
    /* Button grid responsive layout */
    #makeImage {
        display: grid;
        grid-template-columns: 1fr; /* Single column on mobile */
        gap: clamp(0.5rem, 2vw, 1rem);
    }
    
    @media (min-width: 480px) {
        #makeImage {
            grid-template-columns: repeat(2, 1fr); /* Two columns on small tablets */
        }
    }
    
    @media (min-width: 640px) {
        #makeImage {
            grid-template-columns: repeat(5, 1fr); /* Five columns on desktop */
        }
    }
    
    /* Form section improvements */
    .form-section {
        background-color: #f9fafb;
        border-radius: var(--border-radius-lg);
        padding: clamp(1rem, 3vw, 1.5rem);
        margin-bottom: clamp(1rem, 3vw, 1.5rem);
        border: 1px solid #e5e7eb;
    }
    
    .form-section h2 {
        font-size: clamp(1.25rem, 4vw, 1.5rem);
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: clamp(0.75rem, 2vw, 1rem);
        margin-top: 0;
    }
    
    .form-section label {
        font-size: clamp(0.875rem, 2.5vw, 1rem);
        font-weight: 500;
        color: var(--text-secondary);
        margin-bottom: clamp(0.25rem, 1vw, 0.5rem);
        display: block;
    }
    
    /* Grid improvements for form layouts */
    .grid-responsive {
        display: grid;
        gap: clamp(0.75rem, 3vw, 1rem);
        grid-template-columns: 1fr;
    }
    
    @media (min-width: 768px) {
        .grid-responsive {
            grid-template-columns: repeat(2, 1fr);
        }
    }
    
    /* Modal improvements */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        padding: clamp(1rem, 4vw, 2rem); /* Ensure modal doesn't touch edges */
    }

    /* Fullscreen crop modal */
    .crop-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        display: none;
        z-index: 2000;
        touch-action: none; /* Prevent default touch behaviors */
    }

    .crop-modal-overlay.active {
        display: flex;
        flex-direction: column;
    }

    .crop-modal-header {
        background-color: rgba(255, 255, 255, 0.95);
        padding: 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
    }

    .crop-modal-title {
        font-size: 1.25rem;
        font-weight: 600;
        color: var(--text-primary);
        margin: 0;
    }

    .crop-modal-instructions {
        font-size: 0.875rem;
        color: var(--text-secondary);
        margin: 0;
    }

    .crop-modal-content {
        flex: 1;
        position: relative;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: clamp(1rem, 3vw, 2rem); /* Add padding to prevent header/footer overlap */
        min-height: 0; /* Allow flexbox to shrink properly */
    }

    .crop-image-container {
        position: relative;
        max-width: calc(100% - 2rem); /* Account for padding */
        max-height: calc(100% - 2rem); /* Account for padding */
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        touch-action: none;
    }

    .crop-source-image {
        max-width: 90%; /* Reduce from 100% to give breathing room */
        max-height: 90%; /* Reduce from 100% to give breathing room */
        object-fit: contain;
        display: block;
        pointer-events: all; /* Allow clicks to start selection */
        user-select: none;
        cursor: crosshair; /* Indicate clickable for cropping */
    }

    .crop-selection-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }

    .crop-selection-box {
        position: absolute;
        border: 3px solid #fff;
        box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
        cursor: move;
        pointer-events: all;
        min-width: 50px;
        min-height: 50px;
    }

    .crop-handle {
        position: absolute;
        width: 20px;
        height: 20px;
        background-color: #fff;
        border: 2px solid var(--primary-color);
        border-radius: 50%;
        cursor: pointer;
        pointer-events: all;
        touch-action: none;
    }

    .crop-handle.nw { top: -10px; left: -10px; cursor: nw-resize; }
    .crop-handle.ne { top: -10px; right: -10px; cursor: ne-resize; }
    .crop-handle.sw { bottom: -10px; left: -10px; cursor: sw-resize; }
    .crop-handle.se { bottom: -10px; right: -10px; cursor: se-resize; }

    .crop-modal-footer {
        background-color: rgba(255, 255, 255, 0.95);
        padding: 1rem;
        display: flex;
        gap: 1rem;
        justify-content: center;
        flex-shrink: 0;
    }

    .crop-btn {
        padding: 12px 24px;
        border: none;
        border-radius: var(--border-radius);
        font-size: 1rem;
        font-weight: 500;
        cursor: pointer;
        min-width: 100px;
        touch-action: manipulation;
    }

    .crop-btn-cancel {
        background-color: var(--secondary-color);
        color: var(--text-primary);
    }

    .crop-btn-cancel:hover {
        background-color: var(--secondary-hover);
    }

    .crop-btn-ok {
        background-color: var(--primary-color);
        color: white;
    }

    .crop-btn-ok:hover {
        background-color: var(--primary-hover);
    }

    /* Mobile-specific adjustments */
    @media (max-width: 768px) {
        .crop-handle {
            width: 30px;
            height: 30px;
        }
        
        .crop-handle.nw { top: -15px; left: -15px; }
        .crop-handle.ne { top: -15px; right: -15px; }
        .crop-handle.sw { bottom: -15px; left: -15px; }
        .crop-handle.se { bottom: -15px; right: -15px; }

        .crop-modal-header {
            flex-direction: column;
            text-align: center;
            gap: 0.5rem;
        }

        .crop-modal-footer {
            flex-direction: column;
        }
        
        .crop-btn {
            width: 100%;
        }
    }
    
    .modal-content {
        background-color: white;
        padding: clamp(1.5rem, 4vw, 2rem); /* Fluid padding */
        border-radius: var(--border-radius-xl);
        box-shadow: 0 20px 25px rgba(0, 0, 0, 0.1);
        max-width: clamp(300px, 90vw, 400px); /* Fluid max width */
        width: 100%;
        text-align: center;
    }
    
    .modal-content p {
        font-size: clamp(1rem, 3vw, 1.125rem); /* Fluid typography */
        color: var(--text-secondary);
        margin-bottom: clamp(1rem, 3vw, 1.5rem);
    }
    
    .modal-button {
        background-color: var(--primary-color);
        color: white;
        padding: clamp(8px, 2vw, 12px) clamp(16px, 4vw, 24px);
        border-radius: var(--border-radius-lg);
        border: none;
        font-size: clamp(0.875rem, 2.5vw, 1rem);
        font-weight: 500;
        cursor: pointer;
        min-height: 44px;
        min-width: 44px;
        transition: background-color 0.2s ease-in-out;
    }
    
    .modal-button:hover {
        background-color: var(--primary-hover);
    }

    /* Landing screen improvements */
    #landingScreen {
        background-color: #ffffff;
        border-radius: var(--border-radius-xl);
        box-shadow: var(--shadow-lg);
        padding: clamp(2rem, 6vw, 3rem); /* Fluid padding */
        text-align: center;
        max-width: clamp(300px, 90vw, 500px); /* Fluid max width */
        width: 100%;
    }
    
    #landingScreen h1 {
        font-size: clamp(2rem, 6vw, 2.5rem); /* Fluid typography */
        font-weight: 700;
        color: var(--text-primary);
        margin-bottom: clamp(1.5rem, 4vw, 2rem);
    }
    
    #landingScreen p {
        font-size: clamp(1.125rem, 3vw, 1.25rem); /* Fluid typography */
        color: var(--text-secondary);
        margin-bottom: clamp(1rem, 3vw, 1.5rem);
    }
    
    #landingScreen .button-group {
        display: flex;
        flex-direction: column;
        gap: clamp(0.75rem, 2vw, 1rem);
    }
    
    @media (min-width: 480px) {
        #landingScreen .button-group {
            flex-direction: row;
            justify-content: center;
        }
    }
    
    #landingScreen .button-group button {
        font-size: clamp(1rem, 3vw, 1.125rem);
        padding: clamp(12px, 3vw, 16px) clamp(24px, 5vw, 32px);
    }
    
    /* Loading indicator improvements */
    .loading-indicator {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: clamp(0.5rem, 2vw, 1rem);
        margin-top: clamp(1rem, 3vw, 1.5rem);
    }
    
    .loading-spinner {
        width: clamp(24px, 6vw, 32px);
        height: clamp(24px, 6vw, 32px);
        border: 2px solid #e5e7eb;
        border-top: 2px solid var(--primary-color);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    
    .loading-text {
        color: var(--primary-color);
        font-size: clamp(0.875rem, 2.5vw, 1rem);
        font-weight: 500;
    }
    
    /* Result text improvements */
    #resultText {
        font-size: clamp(1rem, 3vw, 1.125rem);
        font-weight: 500;
        color: var(--text-secondary);
        margin-top: clamp(1rem, 3vw, 1.5rem);
        text-align: center;
    }
    
    /* Main title improvements */
    .main-title {
        font-size: clamp(1.875rem, 5vw, 2.25rem); /* Fluid typography */
        font-weight: 700;
        color: var(--text-primary);
        margin-bottom: clamp(1.5rem, 4vw, 2rem);
        text-align: center;
    }
</style>
</head>
<body>

<!-- Custom Message Box -->
<div id="messageBox" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <p id="messageText" class="text-lg text-gray-700">Loading...</p>
        <button id="messageCloseButton" class="modal-button">OK</button>
    </div>
</div>

<!-- Brad Specific Pop-up -->
<div id="bradPopup" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <p id="bradMessage" class="text-lg text-gray-700">Loading witty comment...</p>
        <button id="agreeButton" onclick="agreeToProceed()" class="modal-button" style="display: none;">I agree</button>
    </div>
</div>

<!-- Landing Screen -->
<div id="landingScreen" class="flex flex-col items-center justify-center min-h-screen" style="display: flex;">
    <h1 class="main-title">Welcome to Ciardle Asset Creator</h1>
    <p>Are you Brad?</p>
    <div class="button-group">
        <button onclick="isBrad(true)" class="button-primary">Yes</button>
        <button onclick="isBrad(false)" class="button-secondary">No</button>
    </div>
</div>

<!-- Main Application Content (Initially hidden) -->
<div id="app-container" style="display: none;">
    <h1 class="main-title">Ciardle Image Cropper & Uploader</h1>

    <div class="space-y-6">
        <div class="form-section">
            <label for="uniqueCode">Unique Code (for game asset ID):</label>
            <div class="input-group">
                <input type="text" id="uniqueCode" value="" placeholder="Enter unique code">
                <button onclick="copyLink()" class="button-secondary">Copy Link</button>
            </div>
        </div>

        <!-- Updated Image Loading Section -->
        <div class="form-section">
            <h2>Load Source Image</h2>
            <div class="input-group">
                <input type="text" id="imageURL" value="https://upload.wikimedia.org/wikipedia/commons/5/55/JDV584V_1980_Triumph_Spitfire_1500.jpg" placeholder="Enter image URL">
                <button onclick="loadImageFromUrl()" class="button-primary">Load from URL</button>
            </div>
            <div style="text-align: center; margin: 1rem 0;">
                <span style="color: #6b7280; font-size: 0.875rem;">OR</span>
            </div>
            <div>
                <!-- This input is hidden and triggered by the button below -->
                <input type="file" id="imageUpload" accept="image/*" style="display: none;">
                <button onclick="document.getElementById('imageUpload').click()" class="button-secondary" style="width: 100%;">Upload from Computer</button>
            </div>
        </div>

        <div class="form-section">
            <canvas id="OriginalCanvas"></canvas>
        </div>

        <div class="form-section">
            <h2>Car Details</h2>
            <div class="grid-responsive">
                <div>
                    <label for="CarMake">Make:</label>
                    <input type="text" id="CarMake" value="" placeholder="Enter car make">
                </div>
                <div>
                    <label for="CarModel">Model:</label>
                    <input type="text" id="CarModel" value="" placeholder="Enter car model">
                </div>
            </div>
        </div>

        <div class="form-section">
            <h2>Crop & Preview Images</h2>
            <div id="makeImage">
                <button onclick="cropImage(1)" class="button-secondary">Make Image 1</button>
                <button onclick="cropImage(2)" class="button-secondary">Make Image 2</button>
                <button onclick="cropImage(3)" class="button-secondary">Make Image 3</button>
                <button onclick="cropImage(4)" class="button-secondary">Make Image 4</button>
                <button onclick="cropImage(5)" class="button-secondary">Make Image 5</button>
            </div>
            <div id="croppedImages">
                <img id="Image1" alt="Image 1" class="img-thumbnail">
                <img id="Image2" alt="Image 2" class="img-thumbnail">
                <img id="Image3" alt="Image 3" class="img-thumbnail">
                <img id="Image4" alt="Image 4" class="img-thumbnail">
                <img id="Image5" alt="Image 5" class="img-thumbnail">
            </div>
        </div>

        <div class="form-section" style="text-align: center;">
            <button onclick="uploadImages()" class="button-primary" style="width: 100%; padding: 1rem; font-size: 1.125rem;">Upload All Images & Data</button>
            <p id="resultText"></p>
            <div id="loadingIndicator" class="loading-indicator" style="display: none;">
                <div class="loading-spinner"></div>
                <p class="loading-text">Uploading, please wait...</p>
            </div>
        </div>
    </div>
</div>


<script type="module">
    // --- DOM Elements and Variables ---
    const OriginalCanvas = document.getElementById('OriginalCanvas');
    const ctx = OriginalCanvas.getContext('2d');
    let carImage = new Image(); // Actual picture of car
    carImage.crossOrigin = "anonymous"; // Essential for loading images from other domains onto canvas

    let isDrawing = false;
    let startX, startY; // Mouse coordinates on canvas (clientX/Y relative to canvas)
    let currentX, currentY; // Mouse coordinates on canvas

    const uniqueCodeBox = document.getElementById('uniqueCode');
    // Generate a unique code using UUID (more robust than time for potential collisions)
    uniqueCodeBox.value = crypto.randomUUID().substring(0, 8); // Shorten for display

    const messageBox = document.getElementById('messageBox');
    const messageText = document.getElementById('messageText');
    const messageCloseButton = document.getElementById('messageCloseButton');
    const loadingIndicator = document.getElementById('loadingIndicator');
    const resultText = document.getElementById("resultText");

    const landingScreen = document.getElementById('landingScreen');
    const appContainer = document.getElementById('app-container');
    const bradPopup = document.getElementById('bradPopup');
    const bradMessage = document.getElementById('bradMessage');
    const agreeButton = document.getElementById('agreeButton');

    // NEW: Reference to the file upload input
    const imageUploadInput = document.getElementById('imageUpload');


    // Event listener for closing the custom message box
    messageCloseButton.addEventListener('click', () => {
        console.log("OK button clicked, hiding message box."); // Debugging log
        messageBox.style.display = 'none'; // Directly hide the modal
    });

    /**
     * Displays a custom message box instead of alert().
     * @param {string} message The message to display.
     * @param {boolean} [autoHide=false] If true, hides the message after a few seconds.
     */
    function showMessage(message, autoHide = false) {
        console.log("Showing message:", message); // Debugging log
        messageText.textContent = message;
        messageBox.style.display = 'flex'; // Directly show the modal using flex display

        if (autoHide) {
            setTimeout(() => {
                messageBox.style.display = 'none'; // Directly hide the modal after delay
            }, 3000); // Hide after 3 seconds
        }
    }

    /**
     * Extracts the first meaningful line from a potentially multi-line AI response,
     * ignoring common introductory phrases.
     * @param {string} rawText The raw text received from the AI.
     * @returns {string} The extracted witty comment.
     */
    function extractFirstWittyComment(rawText) {
        const lines = rawText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
        const introductoryPhrases = [
            "Here are a few options, pick your favorite:",
            "Here are a few options:",
            "Here's a witty comment:",
            "Option 1:",
            "1.",
            "- " // For bullet points
        ];

        for (const line of lines) {
            let isIntroductory = false;
            for (const phrase of introductoryPhrases) {
                if (line.startsWith(phrase)) {
                    isIntroductory = true;
                    break;
                }
            }
            if (!isIntroductory) {
                return line; // Return the first line that is not an introductory phrase
            }
        }
        // Fallback: if all lines were introductory or no lines, return a default
        return lines.length > 0 ? lines[0] : "Couldn't fetch a witty comment. Perhaps the AI is still sharpening its crayons.";
    }

    /**
     * Handles the user's response on the landing screen.
     * @param {boolean} isIndeedBrad True if the user claims to be Brad, false otherwise.
     */
    async function isBrad(isIndeedBrad) { // Made async to await AI response
        if (isIndeedBrad) {
            landingScreen.style.display = 'none'; // Hide landing screen
            bradPopup.style.display = 'flex'; // Show Brad specific pop-up
            bradMessage.textContent = "Generating witty comment..."; // Show loading message
            agreeButton.style.display = 'none'; // Hide button while generating

            try {
                let chatHistory = [];
                // Changed "Design Engineer" to "Designer" in the prompt
                const prompt = "Generate a short, witty, and slightly teasing comment about a 'Designer' and their artistic skills, specifically mentioning crayons or felt-tips, suitable for a pop-up message in a game asset creation tool. Keep it lighthearted and humorous. Provide only one comment directly, without any introductory phrases or numbered/bulleted lists.";
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                // IMPORTANT: For deployment outside of this Canvas environment (e.g., GitHub Pages),
                // you MUST provide your actual Gemini API key here.
                // Get your API key from: https://aistudio.google.com/app/apikey
                const apiKey = ""; // Your Gemini API Key - LEAVE BLANK IN CANVAS
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`API call failed with status: ${response.status}`);
                }

                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const rawText = result.candidates[0].content.parts[0].text;
                    bradMessage.textContent = extractFirstWittyComment(rawText); // Use the new function
                } else {
                    bradMessage.textContent = "Couldn't fetch a witty comment. Perhaps the AI is still sharpening its crayons.";
                }
            } catch (error) {
                console.error("Error generating Brad message:", error);
                bradMessage.textContent = "Error generating witty comment. Maybe Brad broke the AI with his abstract art.";
            } finally {
                agreeButton.style.display = 'block'; // Show button after generation (or error)
            }

        } else {
            landingScreen.style.display = 'none'; // Hide landing screen
            appContainer.style.display = 'block'; // Show main app content
            loadImageFromUrl(); // Load default image when main app is shown
        }
    }
    window.isBrad = isBrad; // Make globally accessible

    /**
     * Handles the "I agree" button click on the Brad pop-up.
     */
    function agreeToProceed() {
        bradPopup.style.display = 'none'; // Hide Brad specific pop-up
        appContainer.style.display = 'block'; // Show main app content
        loadImageFromUrl(); // Load default image when main app is shown
    }
    window.agreeToProceed = agreeToProceed; // Make globally accessible


    /**
     * Copies the unique code link to the clipboard.
     */
    function copyLink() {
        const uniqueCode = uniqueCodeBox.value;
        if (!uniqueCode) {
            showMessage("No unique code to copy.");
            return;
        }
        const linkToCopy = `https://nrobbert.github.io/Ciardle/ciardle.html?code=${uniqueCode}`;

        // Create a temporary textarea to copy the text
        const tempTextArea = document.createElement('textarea');
        tempTextArea.value = linkToCopy;
        document.body.appendChild(tempTextArea);
        tempTextArea.select();
        try {
            document.execCommand('copy');
            showMessage("Link copied to clipboard!", true);
        } catch (err) {
            console.error('Failed to copy link:', err);
            showMessage("Failed to copy link. Please copy manually: " + linkToCopy);
        } finally {
            document.body.removeChild(tempTextArea);
        }
    }
    // Make copyLink globally accessible
    window.copyLink = copyLink;


    // --- Image Loading and Canvas Drawing ---

    // When the car image loads, set canvas dimensions and draw the image
    carImage.onload = function() {
        OriginalCanvas.width = carImage.naturalWidth;
        OriginalCanvas.height = carImage.naturalHeight;
        ctx.drawImage(carImage, 0, 0);
        resultText.textContent = "Image loaded. Drag on the canvas to select a crop area.";
    };

    carImage.onerror = function() {
        // This is the specific change to auto-hide the error message on load
        showMessage("Failed to load image. Please check the URL or file.", true); // Auto-hide this message
        resultText.textContent = "Image load failed.";
        // Clear canvas if image fails to load
        ctx.clearRect(0, 0, OriginalCanvas.width, OriginalCanvas.height);
        OriginalCanvas.width = 0;
        OriginalCanvas.height = 0;
    }

    /**
     * Processes and downsizes an image if it's too large.
     * @param {HTMLImageElement} sourceImage - The source image to process
     * @param {number} maxWidth - Maximum width allowed
     * @param {number} maxHeight - Maximum height allowed
     * @param {number} quality - JPEG quality (0.1 to 1.0)
     * @returns {string} Data URL of the processed image
     */
    function processAndDownsizeImage(sourceImage, maxWidth = 2048, maxHeight = 2048, quality = 0.85) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        let { naturalWidth: width, naturalHeight: height } = sourceImage;
        
        // Ensure we have valid dimensions
        if (!width || !height || width <= 0 || height <= 0) {
            throw new Error('Invalid image dimensions');
        }
        
        // Calculate new dimensions if downsizing is needed
        if (width > maxWidth || height > maxHeight) {
            const ratio = Math.min(maxWidth / width, maxHeight / height);
            width = Math.round(width * ratio);
            height = Math.round(height * ratio);
        }
        
        // Set canvas dimensions
        canvas.width = width;
        canvas.height = height;
        
        // Configure canvas for better image quality
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        
        // Clear canvas with white background (helps with transparent images)
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, width, height);
        
        // Draw the image with new dimensions
        ctx.drawImage(sourceImage, 0, 0, width, height);
        
        // Return as data URL with appropriate format and quality
        try {
            return canvas.toDataURL('image/jpeg', quality);
        } catch (e) {
            // Fallback to PNG if JPEG fails
            return canvas.toDataURL('image/png');
        }
    }

    /**
     * Loads an image from the provided URL into the canvas with robust error handling and downsizing.
     */
    function loadImageFromUrl() {
        const url = document.getElementById('imageURL').value;
        if (!url) {
            showMessage("Please enter an image URL.");
            return;
        }
        
        resultText.textContent = "Loading image...";
        // Clear the file input value if a URL is being loaded
        imageUploadInput.value = '';
        
        // Try loading with multiple strategies
        loadImageWithFallback(url, 0);
    }
    
    /**
     * Attempts to load an image with multiple fallback strategies for better reliability.
     * @param {string} url - The image URL to load
     * @param {number} attempt - Current attempt number (0-based)
     */
    function loadImageWithFallback(url, attempt = 0) {
        const strategies = [
            { cors: "anonymous", desc: "with CORS anonymous" },
            { cors: null, desc: "without CORS" },
            { cors: "use-credentials", desc: "with CORS credentials" }
        ];
        
        if (attempt >= strategies.length) {
            showMessage("Failed to load image after trying multiple methods. This may be due to CORS restrictions, server blocking, or network issues. Try uploading the image from your computer instead.", true);
            resultText.textContent = "Image load failed.";
            return;
        }
        
        const strategy = strategies[attempt];
        const tempImage = new Image();
        
        // Add timeout for each attempt
        const timeoutId = setTimeout(() => {
            console.log(`Load attempt ${attempt + 1} timed out (${strategy.desc}), trying next strategy...`);
            loadImageWithFallback(url, attempt + 1);
        }, 15000); // 15 second timeout per attempt
        
        // Set up error handling with retry
        tempImage.onerror = function() {
            clearTimeout(timeoutId);
            console.log(`Load attempt ${attempt + 1} failed (${strategy.desc}), trying next strategy...`);
            // Try next strategy after a short delay
            setTimeout(() => {
                loadImageWithFallback(url, attempt + 1);
            }, 100);
        };
        
        // Set up success handling with processing
        tempImage.onload = function() {
            clearTimeout(timeoutId);
            try {
                // Validate image dimensions
                if (!tempImage.naturalWidth || !tempImage.naturalHeight) {
                    throw new Error('Image loaded but has invalid dimensions');
                }
                
                // Always process the image to create a data URL, avoiding CORS issues
                resultText.textContent = "Processing image...";
                
                const originalSize = tempImage.naturalWidth * tempImage.naturalHeight;
                const maxPixels = 2048 * 2048; // 4 megapixels max
                
                let processedDataUrl;
                if (originalSize > maxPixels) {
                    // Downsize large images
                    processedDataUrl = processAndDownsizeImage(tempImage);
                    showMessage(`Large image (${tempImage.naturalWidth}Ã—${tempImage.naturalHeight}) was downsized for better performance.`, true);
                } else {
                    // Process smaller images without downsizing to ensure we have a data URL
                    processedDataUrl = processAndDownsizeImage(tempImage, tempImage.naturalWidth, tempImage.naturalHeight);
                }
                
                // Always use the processed data URL to avoid CORS issues
                carImage.src = processedDataUrl;
                
            } catch (error) {
                console.error("Image processing error:", error);
                showMessage("Error processing image: " + error.message + ". Try uploading from computer instead.", true);
                resultText.textContent = "Image processing failed.";
            }
        };
        
        // Apply the current strategy
        if (strategy.cors) {
            tempImage.crossOrigin = strategy.cors;
        }
        
        // Start loading the image
        tempImage.src = url;
    }
    // Make functions globally accessible
    window.loadImageFromUrl = loadImageFromUrl;
    window.loadImageWithFallback = loadImageWithFallback;
    window.processAndDownsizeImage = processAndDownsizeImage;

    // NEW: Event listener for the file input
    imageUploadInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                resultText.textContent = "Loading image...";
                // Clear the URL input value if a file is being loaded
                document.getElementById('imageURL').value = '';
                carImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    });


    // --- Canvas Drawing and Cropping Selection ---

    // Mouse down event: Start drawing rectangle
    OriginalCanvas.addEventListener('mousedown', (e) => {
        // Get mouse coordinates relative to the canvas
        const rect = OriginalCanvas.getBoundingClientRect();
        startX = e.clientX - rect.left;
        startY = e.clientY - rect.top;
        isDrawing = true;
        // console.log(`Start Screen: (${startX}, ${startY})`);
    });

    // Mouse move event: Update rectangle while drawing
    OriginalCanvas.addEventListener('mousemove', (e) => {
        if (isDrawing) {
            const rect = OriginalCanvas.getBoundingClientRect();
            currentX = e.clientX - rect.left;
            currentY = e.clientY - rect.top;
            redrawWithRectangle();
        }
    });

    // Mouse up event: Stop drawing
    OriginalCanvas.addEventListener('mouseup', () => {
        isDrawing = false;
    });

    // Mouse out event: Stop drawing if mouse leaves canvas
    OriginalCanvas.addEventListener('mouseout', () => {
        isDrawing = false;
    });

    /**
     * Redraws the canvas with the original image and the current selection rectangle.
     */
    function redrawWithRectangle() {
        // Clear the canvas and redraw the original image
        ctx.clearRect(0, 0, OriginalCanvas.width, OriginalCanvas.height);
        ctx.drawImage(carImage, 0, 0);

        // Calculate scale factors from displayed canvas size to actual image size
        const scaleX = carImage.naturalWidth / OriginalCanvas.clientWidth;
        const scaleY = carImage.naturalHeight / OriginalCanvas.clientHeight;

        // Set stroke style for the rectangle
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2 * Math.max(scaleX, scaleY); // Adjust line width based on scale

        // Calculate actual coordinates for drawing on the internal canvas resolution
        const actualStartX = startX * scaleX;
        const actualStartY = startY * scaleY;
        const actualCurrentX = currentX * scaleX;
        const actualCurrentY = currentY * scaleY;

        // Draw the selection rectangle
        ctx.strokeRect(actualStartX, actualStartY, actualCurrentX - actualStartX, actualCurrentY - actualStartY);

        // console.log(`Canvas Coordinates: (${actualStartX.toFixed(2)}, ${actualStartY.toFixed(2)}) to (${actualCurrentX.toFixed(2)}, ${actualCurrentY.toFixed(2)})`);
    }

    /**
     * Crops the selected region of the image and displays it in the specified image element.
     * @param {number} imgNum The number of the image element (1-5) to display the cropped image.
     */
    function cropImage(imgNum) {
        if (startX === undefined || startY === undefined || currentX === undefined || currentY === undefined || !isFinite(startX)) {
            showMessage("Please select a region to crop by dragging on the image.");
            return;
        }

        // Calculate scale factors from displayed canvas size to actual image size
        const scaleX = carImage.naturalWidth / OriginalCanvas.clientWidth;
        const scaleY = carImage.naturalHeight / OriginalCanvas.clientHeight;

        // Get actual coordinates and dimensions on the original image
        const actualStartX = startX * scaleX;
        const actualStartY = startY * scaleY;
        const actualCurrentX = currentX * scaleX;
        const actualCurrentY = currentY * scaleY;

        const width = Math.abs(actualCurrentX - actualStartX);
        const height = Math.abs(actualCurrentY - actualStartY);

        if (width === 0 || height === 0) {
            showMessage("Selected region has zero width or height. Please select a larger area.");
            return;
        }

        // Create a temporary canvas for cropping
        const croppedCanvas = document.createElement('canvas');
        croppedCanvas.width = width;
        croppedCanvas.height = height;
        const croppedCtx = croppedCanvas.getContext('2d');

        // Determine the top-left corner for cropping (min of start and current)
        const actualX = Math.min(actualStartX, actualCurrentX);
        const actualY = Math.min(actualStartY, actualCurrentY);

        // Draw the cropped portion of the original image onto the temporary canvas
        croppedCtx.drawImage(carImage, actualX, actualY, width, height, 0, 0, width, height);

        // Get the target image element
        const CroppedImage = document.getElementById('Image' + imgNum);
        if (CroppedImage) {
            // Convert the cropped canvas to a Blob and then to an Object URL for display
            croppedCanvas.toBlob((blob) => {
                if (blob) {
                    const imageUrl = URL.createObjectURL(blob);
                    CroppedImage.src = imageUrl;
                    resultText.textContent = `Image ${imgNum} cropped successfully.`;
                } else {
                    showMessage("Failed to create cropped image blob.");
                }
            }, 'image/png');
        } else {
            console.error(`Image element with ID 'Image${imgNum}' not found.`);
        }
    }
    // Make cropImage globally accessible
    window.cropImage = cropImage;

    // --- Touch-Friendly Crop Modal Functions ---

    let currentCropImageNumber = 1;
    let cropSelection = { x: 0, y: 0, width: 200, height: 150 };
    let isDragging = false;
    let isResizing = false;
    let dragStartPos = { x: 0, y: 0 };
    let resizeHandle = null;
    let imageContainer = null;
    let sourceImageElement = null;
    let selectionStarted = false; // Track whether user has started selection

    /**
     * Opens the fullscreen crop modal for the specified image number
     */
    function openCropModal(imageNumber) {
        if (!carImage.src || carImage.naturalWidth === 0) {
            showMessage("Please load an image first.");
            return;
        }

        currentCropImageNumber = imageNumber;
        
        // Update modal title
        document.getElementById('cropImageNumber').textContent = imageNumber;
        
        // Set the source image
        const cropSourceImage = document.getElementById('cropSourceImage');
        cropSourceImage.src = carImage.src;
        
        // Show the modal
        const modal = document.getElementById('cropModal');
        modal.classList.add('active');
        
        // Initialize crop selection after image loads
        cropSourceImage.onload = function() {
            initializeCropSelection();
        };
        
        // If image is already loaded, initialize immediately
        if (cropSourceImage.complete) {
            initializeCropSelection();
        }
    }

    /**
     * Initializes the crop selection box with default position and size
     */
    function initializeCropSelection() {
        imageContainer = document.getElementById('cropImageContainer');
        sourceImageElement = document.getElementById('cropSourceImage');
        
        if (!imageContainer || !sourceImageElement) return;
        
        const containerRect = imageContainer.getBoundingClientRect();
        const imageRect = sourceImageElement.getBoundingClientRect();
        
        // Calculate the actual image dimensions within the container
        const imageWidth = imageRect.width;
        const imageHeight = imageRect.height;
        
        // Set initial selection to center 40% of the image
        const selectionWidth = Math.min(200, imageWidth * 0.4);
        const selectionHeight = Math.min(150, imageHeight * 0.4);
        
        cropSelection = {
            x: (imageWidth - selectionWidth) / 2,
            y: (imageHeight - selectionHeight) / 2,
            width: selectionWidth,
            height: selectionHeight
        };
        
        // Reset selection state when modal opens
        selectionStarted = false;
        
        // Don't show selection initially - wait for user click
        hideCropSelectionDisplay();
        setupCropEventListeners();
    }

    /**
     * Updates the visual display of the crop selection box
     */
    function updateCropSelectionDisplay() {
        const selectionBox = document.getElementById('cropSelectionBox');
        if (!selectionBox) return;
        
        selectionBox.style.left = cropSelection.x + 'px';
        selectionBox.style.top = cropSelection.y + 'px';
        selectionBox.style.width = cropSelection.width + 'px';
        selectionBox.style.height = cropSelection.height + 'px';
        selectionBox.style.display = 'block';
    }

    /**
     * Hides the crop selection box
     */
    function hideCropSelectionDisplay() {
        const selectionBox = document.getElementById('cropSelectionBox');
        if (!selectionBox) return;
        
        selectionBox.style.display = 'none';
    }

    /**
     * Sets up event listeners for crop interaction (both mouse and touch)
     */
    function setupCropEventListeners() {
        const selectionBox = document.getElementById('cropSelectionBox');
        const handles = document.querySelectorAll('.crop-handle');
        
        if (!selectionBox) return;
        
        // Add click/touch listener to image to start selection
        sourceImageElement.addEventListener('mousedown', startCropSelection);
        sourceImageElement.addEventListener('touchstart', startCropSelection, { passive: false });
        
        // Selection box drag events
        selectionBox.addEventListener('mousedown', startDragSelection);
        selectionBox.addEventListener('touchstart', startDragSelection, { passive: false });
        
        // Handle resize events
        handles.forEach(handle => {
            handle.addEventListener('mousedown', (e) => startResizeSelection(e, handle.dataset.handle));
            handle.addEventListener('touchstart', (e) => startResizeSelection(e, handle.dataset.handle), { passive: false });
        });
        
        // Global move and end events
        document.addEventListener('mousemove', handleCropInteraction);
        document.addEventListener('touchmove', handleCropInteraction, { passive: false });
        document.addEventListener('mouseup', endCropInteraction);
        document.addEventListener('touchend', endCropInteraction);
        document.addEventListener('touchcancel', endCropInteraction);
    }

    /**
     * Starts crop selection when user first clicks on image
     */
    function startCropSelection(e) {
        if (selectionStarted) return; // Already started, let normal interaction continue
        
        e.preventDefault();
        e.stopPropagation();
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        const imageRect = sourceImageElement.getBoundingClientRect();
        const mouseX = clientX - imageRect.left;
        const mouseY = clientY - imageRect.top;
        
        // Set selection start position based on click location
        const selectionWidth = Math.min(200, imageRect.width * 0.4);
        const selectionHeight = Math.min(150, imageRect.height * 0.4);
        
        cropSelection = {
            x: Math.max(0, Math.min(mouseX - selectionWidth / 2, imageRect.width - selectionWidth)),
            y: Math.max(0, Math.min(mouseY - selectionHeight / 2, imageRect.height - selectionHeight)),
            width: selectionWidth,
            height: selectionHeight
        };
        
        selectionStarted = true;
        updateCropSelectionDisplay();
    }

    /**
     * Starts dragging the selection box
     */
    function startDragSelection(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        const imageRect = sourceImageElement.getBoundingClientRect();
        
        isDragging = true;
        dragStartPos = {
            x: clientX - imageRect.left - cropSelection.x,
            y: clientY - imageRect.top - cropSelection.y
        };
    }

    /**
     * Starts resizing the selection box
     */
    function startResizeSelection(e, handle) {
        e.preventDefault();
        e.stopPropagation();
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        const imageRect = sourceImageElement.getBoundingClientRect();
        
        isResizing = true;
        resizeHandle = handle;
        dragStartPos = {
            x: clientX - imageRect.left,
            y: clientY - imageRect.top
        };
    }

    /**
     * Handles crop interaction (drag/resize)
     */
    function handleCropInteraction(e) {
        if (!isDragging && !isResizing) return;
        
        e.preventDefault();
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        const imageRect = sourceImageElement.getBoundingClientRect();
        const mouseX = clientX - imageRect.left;
        const mouseY = clientY - imageRect.top;
        
        if (isDragging) {
            // Move the selection box
            const newX = Math.max(0, Math.min(mouseX - dragStartPos.x, imageRect.width - cropSelection.width));
            const newY = Math.max(0, Math.min(mouseY - dragStartPos.y, imageRect.height - cropSelection.height));
            
            cropSelection.x = newX;
            cropSelection.y = newY;
        } else if (isResizing && resizeHandle) {
            // Resize the selection box
            const deltaX = mouseX - dragStartPos.x;
            const deltaY = mouseY - dragStartPos.y;
            
            const newSelection = { ...cropSelection };
            
            switch (resizeHandle) {
                case 'nw':
                    newSelection.x = Math.max(0, Math.min(cropSelection.x + deltaX, cropSelection.x + cropSelection.width - 50));
                    newSelection.y = Math.max(0, Math.min(cropSelection.y + deltaY, cropSelection.y + cropSelection.height - 50));
                    newSelection.width = cropSelection.width - (newSelection.x - cropSelection.x);
                    newSelection.height = cropSelection.height - (newSelection.y - cropSelection.y);
                    break;
                case 'ne':
                    newSelection.y = Math.max(0, Math.min(cropSelection.y + deltaY, cropSelection.y + cropSelection.height - 50));
                    newSelection.width = Math.max(50, Math.min(mouseX - cropSelection.x, imageRect.width - cropSelection.x));
                    newSelection.height = cropSelection.height - (newSelection.y - cropSelection.y);
                    break;
                case 'sw':
                    newSelection.x = Math.max(0, Math.min(cropSelection.x + deltaX, cropSelection.x + cropSelection.width - 50));
                    newSelection.width = cropSelection.width - (newSelection.x - cropSelection.x);
                    newSelection.height = Math.max(50, Math.min(mouseY - cropSelection.y, imageRect.height - cropSelection.y));
                    break;
                case 'se':
                    newSelection.width = Math.max(50, Math.min(mouseX - cropSelection.x, imageRect.width - cropSelection.x));
                    newSelection.height = Math.max(50, Math.min(mouseY - cropSelection.y, imageRect.height - cropSelection.y));
                    break;
            }
            
            // Apply constraints to keep selection within image bounds
            if (newSelection.x + newSelection.width <= imageRect.width && 
                newSelection.y + newSelection.height <= imageRect.height &&
                newSelection.width >= 50 && newSelection.height >= 50) {
                cropSelection = newSelection;
            }
            
            dragStartPos = { x: mouseX, y: mouseY };
        }
        
        updateCropSelectionDisplay();
    }

    /**
     * Ends crop interaction
     */
    function endCropInteraction(e) {
        isDragging = false;
        isResizing = false;
        resizeHandle = null;
    }

    /**
     * Closes the crop modal
     */
    function closeCropModal() {
        const modal = document.getElementById('cropModal');
        modal.classList.remove('active');
        
        // Clean up event listeners
        document.removeEventListener('mousemove', handleCropInteraction);
        document.removeEventListener('touchmove', handleCropInteraction);
        document.removeEventListener('mouseup', endCropInteraction);
        document.removeEventListener('touchend', endCropInteraction);
        document.removeEventListener('touchcancel', endCropInteraction);
    }

    /**
     * Applies the crop and creates the cropped image
     */
    function applyCrop() {
        if (!sourceImageElement || !carImage.src) {
            showMessage("No image to crop.");
            return;
        }
        
        // Calculate scale factors from displayed image size to actual image size
        const imageRect = sourceImageElement.getBoundingClientRect();
        const scaleX = carImage.naturalWidth / imageRect.width;
        const scaleY = carImage.naturalHeight / imageRect.height;
        
        // Get actual coordinates and dimensions on the original image
        const actualX = cropSelection.x * scaleX;
        const actualY = cropSelection.y * scaleY;
        const actualWidth = cropSelection.width * scaleX;
        const actualHeight = cropSelection.height * scaleY;
        
        // Create a temporary canvas for cropping
        const croppedCanvas = document.createElement('canvas');
        croppedCanvas.width = actualWidth;
        croppedCanvas.height = actualHeight;
        const croppedCtx = croppedCanvas.getContext('2d');
        
        // Draw the cropped portion of the original image onto the temporary canvas
        croppedCtx.drawImage(carImage, actualX, actualY, actualWidth, actualHeight, 0, 0, actualWidth, actualHeight);
        
        // Get the target image element
        const CroppedImage = document.getElementById('Image' + currentCropImageNumber);
        if (CroppedImage) {
            // Convert the cropped canvas to a Blob and then to an Object URL for display
            croppedCanvas.toBlob((blob) => {
                if (blob) {
                    const imageUrl = URL.createObjectURL(blob);
                    CroppedImage.src = imageUrl;
                    resultText.textContent = `Image ${currentCropImageNumber} cropped successfully.`;
                    
                    // Close the modal
                    closeCropModal();
                    
                    // Auto-advance to next image if not the last one
                    if (currentCropImageNumber < 5) {
                        setTimeout(() => {
                            openCropModal(currentCropImageNumber + 1);
                        }, 500);
                    }
                } else {
                    showMessage("Failed to create cropped image blob.");
                }
            }, 'image/png');
        } else {
            console.error(`Image element with ID 'Image${currentCropImageNumber}' not found.`);
        }
    }

    // Make functions globally accessible
    window.openCropModal = openCropModal;
    window.closeCropModal = closeCropModal;
    window.applyCrop = applyCrop;

    // Override the original cropImage function to use the new modal
    function cropImageWithModal(imgNum) {
        openCropModal(imgNum);
    }
    
    // Replace the global cropImage function
    window.cropImage = cropImageWithModal;


    // --- Cloudinary Upload Functions ---

    /**
     * Uploads an HTML <img> element's content to Cloudinary.
     * @param {HTMLImageElement} imageElement The <img> element to upload.
     * @param {string} cloudName Your Cloudinary cloud name.
     * @param {string} uploadPreset Your Cloudinary upload preset.
     * @param {string} publicId The desired public ID for the uploaded image.
     * @param {string} filename The filename for the uploaded image.
     * @returns {Promise<Object>} A promise that resolves with the Cloudinary response data.
     */
    async function uploadImageToCloudinary(imageElement, cloudName, uploadPreset, publicId, filename) {
        return new Promise((resolve, reject) => {
            if (!imageElement || imageElement.tagName !== 'IMG' || !imageElement.src) {
                reject(new Error('Invalid or empty image element provided.'));
                return;
            }

            if (!cloudName || !uploadPreset || !publicId) {
                reject(new Error('Cloud name, upload preset, and public ID are required for Cloudinary upload.'));
                return;
            }

            // Create a temporary canvas to draw the image and get its blob
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Set canvas dimensions to the image's natural dimensions
            canvas.width = imageElement.naturalWidth;
            canvas.height = imageElement.naturalHeight;

            // Draw the image onto the canvas
            ctx.drawImage(imageElement, 0, 0);

            // Convert canvas content to a Blob
            canvas.toBlob(async (blob) => {
                if (!blob) {
                    reject(new Error('Failed to create image blob from element.'));
                    return;
                }

                const formData = new FormData();
                formData.append('file', blob, filename || 'image.png');
                formData.append('upload_preset', uploadPreset);
                formData.append('public_id', publicId); // Set public_id

                try {
                    const response = await fetch(
                        `https://api.cloudinary.com/v1_1/${cloudName}/image/upload`,
                        {
                            method: 'POST',
                            body: formData,
                        }
                    );

                    if (!response.ok) {
                        const errorData = await response.json();
                        reject(new Error(`Cloudinary image upload failed: ${errorData.error.message || response.statusText}`));
                        return;
                    }

                    const data = await response.json();
                    resolve(data);
                } catch (error) {
                    reject(error);
                }
            }, 'image/png'); // Specify image format
        });
    }

    /**
     * Uploads a <canvas> element's content to Cloudinary.
     * @param {HTMLCanvasElement} canvasElement The <canvas> element to upload.
     * @param {string} cloudName Your Cloudinary cloud name.
     * @param {string} uploadPreset Your Cloudinary upload preset.
     * @param {string} publicId The desired public ID for the uploaded image.
     * @param {string} filename The filename for the uploaded image.
     * @returns {Promise<Object>} A promise that resolves with the Cloudinary response data.
     */
    async function uploadCanvasToCloudinary(canvasElement, cloudName, uploadPreset, publicId, filename) {
        return new Promise((resolve, reject) => {
            if (!canvasElement || canvasElement.tagName !== 'CANVAS') {
                reject(new Error('Invalid canvas element provided.'));
                return;
            }

            if (!cloudName || !uploadPreset || !publicId) {
                reject(new Error('Cloud name, upload preset, and public ID are required for Cloudinary upload.'));
                return;
            }

            // Convert canvas content to a Blob
            canvasElement.toBlob(async (blob) => {
                if (!blob) {
                    reject(new Error('Failed to create image blob from canvas.'));
                    return;
                }

                const formData = new FormData();
                formData.append('file', blob, filename || 'canvas_image.png');
                formData.append('upload_preset', uploadPreset);
                formData.append('public_id', publicId); // Set public_id

                try {
                    const response = await fetch(
                        `https://api.cloudinary.com/v1_1/${cloudName}/image/upload`,
                        {
                            method: 'POST',
                            body: formData,
                        }
                    );

                    if (!response.ok) {
                        const errorData = await response.json();
                        reject(new Error(`Cloudinary canvas upload failed: ${errorData.error.message || response.statusText}`));
                        return;
                    }

                    const data = await response.json();
                    resolve(data);
                } catch (error) {
                    reject(error);
                }
            }, 'image/png'); // Specify image format
        });
    }

    /**
     * Uploads text content as a raw file to Cloudinary.
     * @param {string} make The car make string.
     * @param {string} model The car model string.
     * @param {string} cloudName Your Cloudinary cloud name.
     * @param {string} uploadPreset Your Cloudinary upload preset.
     * @param {string} publicId The desired public ID for the uploaded text file.
     * @param {string} filename The filename for the uploaded text file.
     * @returns {Promise<Object>} A promise that resolves with the Cloudinary response data.
     */
    async function uploadTextFileToCloudinary(make, model, cloudName, uploadPreset, publicId, filename) {
        return new Promise(async (resolve, reject) => {
            if (!cloudName || !uploadPreset || !publicId || !filename) {
                reject(new Error('Cloud name, upload preset, public ID, and filename are required for text file upload.'));
                return;
            }

            const textContent = `${make}\n${model}`; // Combine strings with newline, without "Make: " and "Model: "

            try {
                const blob = new Blob([textContent], { type: 'text/plain' });
                const formData = new FormData();
                formData.append('file', blob, filename);
                formData.append('upload_preset', uploadPreset);
                formData.append('public_id', publicId);

                const response = await fetch(
                    `https://api.cloudinary.com/v1_1/${cloudName}/raw/upload`, // Use 'raw' for text files
                    {
                        method: 'POST',
                        body: formData,
                    }
                );

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Cloudinary Text Upload Error:', errorData);
                    reject(new Error(`Cloudinary text file upload failed: ${errorData.error.message || response.statusText}`));
                    return;
                }

                const data = await response.json();
                resolve(data);
            } catch (error) {
                reject(error);
            }
        });
    }

    // --- Main Upload Function ---

    /**
     * Handles the entire upload process: main image, cropped images, and car details to Cloudinary.
     */
    async function uploadImages() {
        const uniqueCode = document.getElementById('uniqueCode').value;
        const carMake = document.getElementById('CarMake').value;
        const carModel = document.getElementById('CarModel').value;

        // Basic validation
        if (!uniqueCode) {
            showMessage("Please ensure Unique Code is filled.");
            return;
        }
        if (!carMake || !carModel) { // Added validation for CarMake and CarModel
            showMessage("Please ensure Car Make and Car Model are filled.");
            return;
        }

        // Check if main image is loaded
        if (!carImage.src || carImage.naturalWidth === 0) {
            showMessage("Please load an image first.");
            return;
        }

        // Check if at least one cropped image is made
        let hasCroppedImage = false;
        for (let i = 1; i <= 5; i++) {
            const imgElement = document.getElementById('Image' + i);
            if (imgElement && imgElement.src && imgElement.src.startsWith('blob:')) {
                hasCroppedImage = true;
                break; // Found at least one, no need to check further
            }
        }
        if (!hasCroppedImage) {
            showMessage("Please crop at least one image before uploading.");
            return;
        }

        // Clear previous messages and show loading indicator
        resultText.textContent = "";
        loadingIndicator.style.display = 'flex';

        // Cloudinary configuration (replace with your actual Cloudinary details)
        const cloudName = 'nickrobberts'; // Your Cloudinary cloud name
        const uploadPreset = 'ciardleupload'; // Your Cloudinary upload preset

        try {
            // Clear the canvas and redraw the original image WITHOUT the selection rectangle
            // This ensures the uploaded main image does not have the red box.
            ctx.clearRect(0, 0, OriginalCanvas.width, OriginalCanvas.height);
            ctx.drawImage(carImage, 0, 0);

            // 1. Upload Main Canvas Image
            const FullCanvas = document.getElementById('OriginalCanvas');
            const mainImageResult = await uploadCanvasToCloudinary(FullCanvas, cloudName, uploadPreset, 'ciardleImage' + uniqueCode, 'ciardleImage' + uniqueCode);
            console.log('Main image upload successful:', mainImageResult);

            // 2. Upload Cropped Images
            for (let i = 1; i <= 5; i++) {
                const imgElement = document.getElementById('Image' + i);
                if (imgElement && imgElement.src && imgElement.src.startsWith('blob:')) { // Only upload if image exists and is a blob (cropped)
                    const publicId = `ciardleImage${uniqueCode}${i}`;
                    const filename = `ciardleImage${uniqueCode}${i}`;
                    const croppedResult = await uploadImageToCloudinary(imgElement, cloudName, uploadPreset, publicId, filename);
                    console.log(`Cropped image ${i} upload successful:`, croppedResult);
                }
            }

            // 3. Upload Text File (Make and Model)
            const textPublicId = `ciardleText${uniqueCode}`;
            const textFilename = `ciardleText${uniqueCode}`;
            const textResult = await uploadTextFileToCloudinary(carMake, carModel, cloudName, uploadPreset, textPublicId, textFilename);
            console.log('Text file upload successful:', textResult);

            resultText.textContent = "All images and data uploaded successfully!";
            showMessage("Upload Complete!", true); // Auto-hide this success message

        } catch (error) {
            console.error('Upload process failed:', error);
            resultText.textContent = "Upload failed. See console for details.";
            showMessage(`Upload Failed: ${error.message}`); // Keep this error message for manual dismissal
        } finally {
            loadingIndicator.style.display = 'none'; // Hide loading indicator
        }
    }
    // Make uploadImages globally accessible
    window.uploadImages = uploadImages;

</script>

<!-- Fullscreen Crop Modal -->
<div id="cropModal" class="crop-modal-overlay">
    <div class="crop-modal-header">
        <div>
            <h3 class="crop-modal-title">Crop Image <span id="cropImageNumber">1</span></h3>
            <p class="crop-modal-instructions">Drag the selection box and resize using the corner handles</p>
        </div>
    </div>
    <div class="crop-modal-content">
        <div class="crop-image-container" id="cropImageContainer">
            <img id="cropSourceImage" class="crop-source-image" src="" alt="Source image for cropping">
            <div class="crop-selection-overlay" id="cropSelectionOverlay">
                <div class="crop-selection-box" id="cropSelectionBox">
                    <div class="crop-handle nw" data-handle="nw"></div>
                    <div class="crop-handle ne" data-handle="ne"></div>
                    <div class="crop-handle sw" data-handle="sw"></div>
                    <div class="crop-handle se" data-handle="se"></div>
                </div>
            </div>
        </div>
    </div>
    <div class="crop-modal-footer">
        <button type="button" class="crop-btn crop-btn-cancel" onclick="closeCropModal()">Cancel</button>
        <button type="button" class="crop-btn crop-btn-ok" onclick="applyCrop()">Crop Image</button>
    </div>
</div>

</body>
</html>
